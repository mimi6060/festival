# 3. Tests d'Authentification

## 3.1 Test de Brute Force

```bash
# Test avec Hydra
hydra -l user@test.festival.io -P /usr/share/wordlists/rockyou.txt \
  https://staging-api.festival.io/api/auth/login \
  http-post-form "email=^USER^&password=^PASS^:Invalid credentials"

# Verification du rate limiting
for i in {1..50}; do
  curl -s -X POST https://staging-api.festival.io/api/auth/login \
    -H "Content-Type: application/json" \
    -d '{"email":"test@test.com","password":"wrong"}' \
    -w "%{http_code}\n" -o /dev/null
  sleep 0.1
done

# Resultat attendu: 429 (Too Many Requests) apres 5-10 tentatives
```

## 3.2 Test JWT Token

```python
#!/usr/bin/env python3
"""
jwt_test.py - Tests de securite JWT
"""
import jwt
import requests
import json
from datetime import datetime, timedelta

BASE_URL = "https://staging-api.festival.io"

def get_token():
    """Obtenir un token valide"""
    resp = requests.post(f"{BASE_URL}/api/auth/login", json={
        "email": "user@test.festival.io",
        "password": "TestUser123!"
    })
    return resp.json().get("accessToken")

def test_jwt_none_algorithm(token):
    """Test CVE-2015-9235 - Algorithm None"""
    try:
        # Decoder sans verification
        payload = jwt.decode(token, options={"verify_signature": False})

        # Re-encoder avec algorithm none
        fake_token = jwt.encode(payload, key="", algorithm="none")

        # Tester
        resp = requests.get(f"{BASE_URL}/api/auth/me",
                          headers={"Authorization": f"Bearer {fake_token}"})

        if resp.status_code == 200:
            print("[CRITIQUE] Vulnerable a l'algorithme 'none'!")
        else:
            print("[OK] Protection contre l'algorithme 'none'")
    except Exception as e:
        print(f"[OK] Token rejete: {e}")

def test_jwt_key_confusion(token):
    """Test d'attaque RS256 -> HS256"""
    try:
        payload = jwt.decode(token, options={"verify_signature": False})

        # Essayer de signer avec la cle publique
        public_key = """-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...
-----END PUBLIC KEY-----"""

        fake_token = jwt.encode(payload, public_key, algorithm="HS256")

        resp = requests.get(f"{BASE_URL}/api/auth/me",
                          headers={"Authorization": f"Bearer {fake_token}"})

        if resp.status_code == 200:
            print("[CRITIQUE] Vulnerable a la confusion RS256/HS256!")
        else:
            print("[OK] Protection contre la confusion d'algorithme")
    except Exception as e:
        print(f"[OK] Token rejete: {e}")

def test_jwt_expiration(token):
    """Test d'expiration du token"""
    payload = jwt.decode(token, options={"verify_signature": False})

    exp = datetime.fromtimestamp(payload.get("exp", 0))
    now = datetime.now()

    ttl = (exp - now).total_seconds()

    if ttl > 3600:  # Plus d'1 heure
        print(f"[WARNING] TTL trop long: {ttl/3600:.1f} heures")
    else:
        print(f"[OK] TTL correct: {ttl/60:.0f} minutes")

def test_jwt_sensitive_data(token):
    """Verifier les donnees sensibles dans le JWT"""
    payload = jwt.decode(token, options={"verify_signature": False})

    sensitive_fields = ["password", "card", "ssn", "secret", "apiKey"]
    found = []

    for field in sensitive_fields:
        if field.lower() in str(payload).lower():
            found.append(field)

    if found:
        print(f"[CRITIQUE] Donnees sensibles dans JWT: {found}")
    else:
        print("[OK] Pas de donnees sensibles dans le JWT")

    print(f"[INFO] Payload: {json.dumps(payload, indent=2)}")

def test_refresh_token():
    """Test du refresh token"""
    # Login pour obtenir les tokens
    resp = requests.post(f"{BASE_URL}/api/auth/login", json={
        "email": "user@test.festival.io",
        "password": "TestUser123!"
    })
    data = resp.json()

    access_token = data.get("accessToken")
    refresh_token = data.get("refreshToken")

    # Test 1: Utiliser le refresh token
    resp = requests.post(f"{BASE_URL}/api/auth/refresh",
                        headers={"Authorization": f"Bearer {refresh_token}"})

    if resp.status_code == 200:
        print("[OK] Refresh token fonctionne")
        new_tokens = resp.json()

        # Test 2: L'ancien access token doit etre invalide
        resp2 = requests.get(f"{BASE_URL}/api/auth/me",
                           headers={"Authorization": f"Bearer {access_token}"})

        # Note: Selon implementation, l'ancien token peut encore etre valide
        # jusqu'a expiration

        # Test 3: Le refresh token ne doit pas etre reutilisable
        resp3 = requests.post(f"{BASE_URL}/api/auth/refresh",
                            headers={"Authorization": f"Bearer {refresh_token}"})

        if resp3.status_code == 200:
            print("[WARNING] Refresh token reutilisable (rotation non implementee)")
        else:
            print("[OK] Rotation du refresh token implementee")
    else:
        print(f"[ERROR] Refresh token echoue: {resp.status_code}")

if __name__ == "__main__":
    print("=== Tests JWT Festival Platform ===\n")

    token = get_token()
    if not token:
        print("Impossible d'obtenir un token")
        exit(1)

    test_jwt_none_algorithm(token)
    test_jwt_key_confusion(token)
    test_jwt_expiration(token)
    test_jwt_sensitive_data(token)
    test_refresh_token()
```

## 3.3 Test Password Reset

```bash
# Test 1: Enumeration des utilisateurs
curl -X POST https://staging-api.festival.io/api/auth/forgot-password \
  -H "Content-Type: application/json" \
  -d '{"email":"existing@user.com"}'
# Response doit etre identique pour email existant ou non

# Test 2: Token previsible
# Capturer plusieurs tokens de reset et analyser le pattern
# Verifier si le token contient des donnees previsibles (timestamp, userId)

# Test 3: Expiration du token
# Le token doit expirer apres 1 heure max

# Test 4: Reutilisation du token
# Un token ne doit pas etre reutilisable apres changement
```

## 3.4 Test Session Management

```python
#!/usr/bin/env python3
"""
session_test.py - Tests de gestion de session
"""
import requests

BASE_URL = "https://staging-api.festival.io"

def test_session_fixation():
    """Test de fixation de session"""
    # Obtenir un token avant login
    # Non applicable pour JWT (pas de session cote serveur)
    print("[N/A] Session fixation non applicable pour JWT")

def test_concurrent_sessions():
    """Test des sessions simultanees"""
    # Login depuis "appareil 1"
    resp1 = requests.post(f"{BASE_URL}/api/auth/login", json={
        "email": "user@test.festival.io",
        "password": "TestUser123!"
    })
    token1 = resp1.json().get("accessToken")

    # Login depuis "appareil 2"
    resp2 = requests.post(f"{BASE_URL}/api/auth/login", json={
        "email": "user@test.festival.io",
        "password": "TestUser123!"
    })
    token2 = resp2.json().get("accessToken")

    # Les deux tokens doivent fonctionner (comportement attendu pour mobile)
    resp1_check = requests.get(f"{BASE_URL}/api/auth/me",
                               headers={"Authorization": f"Bearer {token1}"})
    resp2_check = requests.get(f"{BASE_URL}/api/auth/me",
                               headers={"Authorization": f"Bearer {token2}"})

    if resp1_check.status_code == 200 and resp2_check.status_code == 200:
        print("[INFO] Sessions simultanees autorisees (normal pour mobile)")
    else:
        print("[INFO] Une seule session autorisee")

def test_logout_invalidation():
    """Test d'invalidation apres logout"""
    # Login
    resp = requests.post(f"{BASE_URL}/api/auth/login", json={
        "email": "user@test.festival.io",
        "password": "TestUser123!"
    })
    token = resp.json().get("accessToken")

    # Logout
    requests.post(f"{BASE_URL}/api/auth/logout",
                 headers={"Authorization": f"Bearer {token}"})

    # Tenter d'utiliser le token
    resp_check = requests.get(f"{BASE_URL}/api/auth/me",
                             headers={"Authorization": f"Bearer {token}"})

    if resp_check.status_code == 401:
        print("[OK] Token invalide apres logout")
    else:
        print("[WARNING] Token encore valide apres logout (blacklist necessaire)")

if __name__ == "__main__":
    test_session_fixation()
    test_concurrent_sessions()
    test_logout_invalidation()
```

---
