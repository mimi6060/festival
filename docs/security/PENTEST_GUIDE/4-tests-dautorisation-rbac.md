# 4. Tests d'Autorisation (RBAC)

## 4.1 Matrice des Permissions

| Endpoint               | ADMIN | ORGANIZER | STAFF | CASHIER | SECURITY | USER |
| ---------------------- | ----- | --------- | ----- | ------- | -------- | ---- |
| GET /users             | OK    | 403       | 403   | 403     | 403      | 403  |
| POST /festivals        | OK    | OK        | 403   | 403     | 403      | 403  |
| POST /tickets/validate | OK    | OK        | OK    | 403     | OK       | 403  |
| POST /cashless/pay     | OK    | OK        | OK    | OK      | 403      | 403  |
| GET /tickets/me        | OK    | OK        | OK    | OK      | OK       | OK   |

## 4.2 Script de Test RBAC

```python
#!/usr/bin/env python3
"""
rbac_test.py - Tests complets RBAC
"""
import requests
import json

BASE_URL = "https://staging-api.festival.io"

# Credentials par role
USERS = {
    "ADMIN": {"email": "admin@test.festival.io", "password": "TestAdmin123!"},
    "ORGANIZER": {"email": "organizer@test.festival.io", "password": "TestOrg123!"},
    "STAFF": {"email": "staff@test.festival.io", "password": "TestStaff123!"},
    "CASHIER": {"email": "cashier@test.festival.io", "password": "TestCash123!"},
    "SECURITY": {"email": "security@test.festival.io", "password": "TestSec123!"},
    "USER": {"email": "user@test.festival.io", "password": "TestUser123!"},
}

# Endpoints a tester avec permission attendue
ENDPOINTS = [
    # (method, path, body, required_role)
    ("GET", "/api/users", None, "ADMIN"),
    ("GET", "/api/users/stats", None, "ADMIN"),
    ("POST", "/api/festivals", {"name": "Test", "startDate": "2026-06-01"}, "ORGANIZER"),
    ("PUT", "/api/festivals/{festival_id}", {"name": "Updated"}, "ORGANIZER"),
    ("DELETE", "/api/festivals/{festival_id}", None, "ADMIN"),
    ("POST", "/api/tickets/validate", {"qrCode": "test"}, "STAFF"),
    ("POST", "/api/cashless/pay", {"amount": 10, "vendorId": "xxx"}, "CASHIER"),
    ("POST", "/api/cashless/topup", {"amount": 50}, "USER"),
    ("GET", "/api/tickets/me", None, "USER"),
    ("GET", "/api/analytics/dashboard", None, "ORGANIZER"),
    ("POST", "/api/staff", {"userId": "xxx", "role": "SECURITY"}, "ORGANIZER"),
    ("GET", "/api/zones", None, "STAFF"),
    ("POST", "/api/zones/{zone_id}/scan", {"ticketId": "xxx"}, "SECURITY"),
]

def get_token(role):
    """Obtenir un token pour un role"""
    creds = USERS.get(role)
    if not creds:
        return None

    resp = requests.post(f"{BASE_URL}/api/auth/login", json=creds)
    if resp.status_code == 200:
        return resp.json().get("accessToken")
    return None

def test_endpoint(method, path, body, token):
    """Tester un endpoint avec un token"""
    headers = {"Authorization": f"Bearer {token}"} if token else {}

    if method == "GET":
        resp = requests.get(f"{BASE_URL}{path}", headers=headers)
    elif method == "POST":
        resp = requests.post(f"{BASE_URL}{path}", json=body, headers=headers)
    elif method == "PUT":
        resp = requests.put(f"{BASE_URL}{path}", json=body, headers=headers)
    elif method == "DELETE":
        resp = requests.delete(f"{BASE_URL}{path}", headers=headers)

    return resp.status_code

def run_rbac_tests():
    """Executer tous les tests RBAC"""
    # Obtenir les tokens
    tokens = {}
    for role in USERS.keys():
        tokens[role] = get_token(role)
        if not tokens[role]:
            print(f"[WARNING] Impossible d'obtenir token pour {role}")

    results = []

    # Hierarchie des roles
    HIERARCHY = {
        "ADMIN": ["ADMIN"],
        "ORGANIZER": ["ADMIN", "ORGANIZER"],
        "STAFF": ["ADMIN", "ORGANIZER", "STAFF"],
        "CASHIER": ["ADMIN", "ORGANIZER", "CASHIER"],
        "SECURITY": ["ADMIN", "ORGANIZER", "SECURITY"],
        "USER": ["ADMIN", "ORGANIZER", "STAFF", "CASHIER", "SECURITY", "USER"],
    }

    print("\n=== Tests RBAC Festival Platform ===\n")

    for method, path, body, min_role in ENDPOINTS:
        print(f"\n{method} {path} (min: {min_role})")

        allowed_roles = HIERARCHY.get(min_role, [min_role])

        for role, token in tokens.items():
            if not token:
                continue

            status = test_endpoint(method, path, body, token)

            expected_ok = role in allowed_roles
            actual_ok = status in [200, 201, 204]

            if expected_ok and not actual_ok:
                print(f"  [{role}] FAIL - Expected OK, got {status}")
                results.append(("FAIL", role, path, "should_allow"))
            elif not expected_ok and actual_ok:
                print(f"  [{role}] CRITICAL - Unauthorized access! Got {status}")
                results.append(("CRITICAL", role, path, "unauthorized_access"))
            elif expected_ok and actual_ok:
                print(f"  [{role}] OK - {status}")
            else:
                print(f"  [{role}] OK - Blocked ({status})")

    # Resume
    print("\n=== Resume ===")
    critical = [r for r in results if r[0] == "CRITICAL"]
    fails = [r for r in results if r[0] == "FAIL"]

    if critical:
        print(f"\n[CRITIQUE] {len(critical)} acces non autorises detectes:")
        for c in critical:
            print(f"  - {c[1]} a acces a {c[2]}")

    if fails:
        print(f"\n[WARNING] {len(fails)} permissions manquantes:")
        for f in fails:
            print(f"  - {f[1]} n'a pas acces a {f[2]}")

    if not critical and not fails:
        print("\n[OK] Tous les tests RBAC passes avec succes")

if __name__ == "__main__":
    run_rbac_tests()
```

## 4.3 Tests IDOR (Insecure Direct Object Reference)

```python
#!/usr/bin/env python3
"""
idor_test.py - Tests IDOR
"""
import requests
import uuid

BASE_URL = "https://staging-api.festival.io"

def get_tokens():
    """Obtenir tokens pour 2 utilisateurs differents"""
    users = [
        {"email": "user1@test.festival.io", "password": "TestUser123!"},
        {"email": "user2@test.festival.io", "password": "TestUser123!"},
    ]

    tokens = []
    for user in users:
        resp = requests.post(f"{BASE_URL}/api/auth/login", json=user)
        if resp.status_code == 200:
            data = resp.json()
            tokens.append({
                "token": data.get("accessToken"),
                "userId": data.get("user", {}).get("id")
            })

    return tokens

def test_ticket_idor():
    """Test IDOR sur les tickets"""
    tokens = get_tokens()
    if len(tokens) < 2:
        print("[SKIP] Besoin de 2 utilisateurs")
        return

    user1, user2 = tokens[0], tokens[1]

    # User1 cree/achete un ticket
    # (On suppose qu'un ticket existe deja pour user1)

    # Obtenir les tickets de user1
    resp = requests.get(f"{BASE_URL}/api/tickets/me",
                       headers={"Authorization": f"Bearer {user1['token']}"})

    if resp.status_code == 200 and resp.json():
        ticket_id = resp.json()[0].get("id")

        # User2 tente d'acceder au ticket de user1
        resp2 = requests.get(f"{BASE_URL}/api/tickets/{ticket_id}",
                           headers={"Authorization": f"Bearer {user2['token']}"})

        if resp2.status_code == 200:
            print(f"[CRITIQUE] IDOR detecte! User2 peut voir ticket de User1")
        elif resp2.status_code in [403, 404]:
            print(f"[OK] Protection IDOR - Acces refuse ({resp2.status_code})")

        # User2 tente d'annuler le ticket de user1
        resp3 = requests.post(f"{BASE_URL}/api/tickets/{ticket_id}/cancel",
                            headers={"Authorization": f"Bearer {user2['token']}"})

        if resp3.status_code in [200, 201]:
            print(f"[CRITIQUE] IDOR critique! User2 peut annuler ticket de User1")
        else:
            print(f"[OK] Protection IDOR annulation ({resp3.status_code})")

def test_cashless_idor():
    """Test IDOR sur les comptes cashless"""
    tokens = get_tokens()
    if len(tokens) < 2:
        print("[SKIP] Besoin de 2 utilisateurs")
        return

    user1, user2 = tokens[0], tokens[1]

    # Obtenir le compte cashless de user1
    resp = requests.get(f"{BASE_URL}/api/cashless/balance",
                       headers={"Authorization": f"Bearer {user1['token']}"})

    if resp.status_code == 200:
        account_id = resp.json().get("accountId")

        # User2 tente d'acceder au solde de user1
        resp2 = requests.get(f"{BASE_URL}/api/cashless/account/{account_id}",
                           headers={"Authorization": f"Bearer {user2['token']}"})

        if resp2.status_code == 200:
            print(f"[CRITIQUE] IDOR detecte sur compte cashless!")
        else:
            print(f"[OK] Protection IDOR cashless ({resp2.status_code})")

def test_parameter_tampering():
    """Test de manipulation de parametres"""
    tokens = get_tokens()
    if not tokens:
        return

    user = tokens[0]

    # Test 1: Modifier l'userId dans la requete
    resp = requests.put(f"{BASE_URL}/api/users/profile",
                       headers={"Authorization": f"Bearer {user['token']}"},
                       json={
                           "id": str(uuid.uuid4()),  # Faux ID
                           "name": "Hacked"
                       })

    # Le serveur doit ignorer l'ID et utiliser celui du token

    # Test 2: Modifier le festivalId pour acceder a un autre festival
    fake_festival_id = str(uuid.uuid4())
    resp2 = requests.get(f"{BASE_URL}/api/festivals/{fake_festival_id}/tickets",
                        headers={"Authorization": f"Bearer {user['token']}"})

    if resp2.status_code == 200:
        print("[WARNING] Acces possible a un festival non autorise")
    else:
        print(f"[OK] Acces festival refuse ({resp2.status_code})")

if __name__ == "__main__":
    print("=== Tests IDOR ===\n")
    test_ticket_idor()
    test_cashless_idor()
    test_parameter_tampering()
```

## 4.4 Test Multi-Tenant Isolation

```python
#!/usr/bin/env python3
"""
multitenant_test.py - Tests d'isolation multi-tenant
"""
import requests

BASE_URL = "https://staging-api.festival.io"

def test_cross_festival_access():
    """Verifier l'isolation entre festivals"""

    # Login comme organisateur du Festival A
    resp = requests.post(f"{BASE_URL}/api/auth/login", json={
        "email": "organizer-a@test.festival.io",
        "password": "TestOrg123!"
    })
    token_a = resp.json().get("accessToken")
    festival_a_id = "uuid-festival-a"

    # Login comme organisateur du Festival B
    resp = requests.post(f"{BASE_URL}/api/auth/login", json={
        "email": "organizer-b@test.festival.io",
        "password": "TestOrg123!"
    })
    token_b = resp.json().get("accessToken")
    festival_b_id = "uuid-festival-b"

    # Organizer A tente d'acceder aux donnees du Festival B
    tests = [
        ("GET", f"/api/festivals/{festival_b_id}"),
        ("GET", f"/api/festivals/{festival_b_id}/tickets"),
        ("GET", f"/api/festivals/{festival_b_id}/analytics"),
        ("GET", f"/api/festivals/{festival_b_id}/staff"),
        ("PUT", f"/api/festivals/{festival_b_id}"),
        ("DELETE", f"/api/festivals/{festival_b_id}"),
    ]

    print("=== Test Isolation Multi-Tenant ===\n")

    for method, path in tests:
        if method == "GET":
            resp = requests.get(f"{BASE_URL}{path}",
                              headers={"Authorization": f"Bearer {token_a}"})
        elif method == "PUT":
            resp = requests.put(f"{BASE_URL}{path}",
                              headers={"Authorization": f"Bearer {token_a}"},
                              json={"name": "Hacked"})
        elif method == "DELETE":
            resp = requests.delete(f"{BASE_URL}{path}",
                                 headers={"Authorization": f"Bearer {token_a}"})

        if resp.status_code in [200, 201, 204]:
            print(f"[CRITIQUE] {method} {path} - Acces cross-tenant!")
        elif resp.status_code in [403, 404]:
            print(f"[OK] {method} {path} - Bloque ({resp.status_code})")
        else:
            print(f"[INFO] {method} {path} - {resp.status_code}")

if __name__ == "__main__":
    test_cross_festival_access()
```

---
