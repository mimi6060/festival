# ============================================================================
# PostgreSQL Primary Server Configuration
# Festival Management Platform - High Availability Setup
# ============================================================================
# Optimized for: 10,000 - 500,000 concurrent users
# Server specs assumption: 32GB RAM, 8 CPU cores, NVMe SSD
# ============================================================================

# -----------------------------------------------------------------------------
# Connection Settings
# -----------------------------------------------------------------------------
listen_addresses = '*'
port = 5432
max_connections = 500
superuser_reserved_connections = 5

# -----------------------------------------------------------------------------
# Memory Configuration
# For 32GB RAM server (adjust based on actual RAM)
# -----------------------------------------------------------------------------
shared_buffers = 8GB                    # 25% of RAM
effective_cache_size = 24GB             # 75% of RAM
work_mem = 64MB                         # For complex queries
maintenance_work_mem = 2GB              # For VACUUM, CREATE INDEX
wal_buffers = 256MB                     # 3% of shared_buffers or 64MB-256MB
huge_pages = try                        # Use huge pages if available

# -----------------------------------------------------------------------------
# Query Planner
# -----------------------------------------------------------------------------
random_page_cost = 1.1                  # For SSD storage
effective_io_concurrency = 200          # For SSD storage
default_statistics_target = 100         # Increase for complex queries
cpu_tuple_cost = 0.03
cpu_index_tuple_cost = 0.005
cpu_operator_cost = 0.0025

# -----------------------------------------------------------------------------
# Write-Ahead Logging (WAL) - Critical for Replication
# -----------------------------------------------------------------------------
wal_level = replica                     # Required for replication
max_wal_senders = 10                    # Max number of replication connections
wal_keep_size = 2GB                     # WAL segments to keep for replicas
max_replication_slots = 10              # Replication slots for streaming
synchronous_commit = on                 # Data durability (can be 'remote_apply' for sync replication)
wal_compression = on                    # Compress WAL to save disk space
wal_log_hints = on                      # Required for pg_rewind

# WAL Archiving for Point-in-Time Recovery
archive_mode = on
archive_command = '/usr/local/bin/wal-archive.sh %p %f'
archive_timeout = 300                   # Archive incomplete WAL every 5 minutes

# -----------------------------------------------------------------------------
# Replication Settings
# -----------------------------------------------------------------------------
hot_standby = on
hot_standby_feedback = on
max_standby_streaming_delay = 30s
max_standby_archive_delay = 300s

# Synchronous replication (optional - for zero data loss)
# synchronous_standby_names = 'FIRST 1 (replica1, replica2)'

# -----------------------------------------------------------------------------
# Checkpoints
# -----------------------------------------------------------------------------
checkpoint_timeout = 15min
checkpoint_completion_target = 0.9
max_wal_size = 4GB
min_wal_size = 1GB
checkpoint_warning = 30s

# -----------------------------------------------------------------------------
# Background Writer
# -----------------------------------------------------------------------------
bgwriter_delay = 200ms
bgwriter_lru_maxpages = 100
bgwriter_lru_multiplier = 2.0
bgwriter_flush_after = 512kB

# -----------------------------------------------------------------------------
# Autovacuum - Optimized for high-write workload
# -----------------------------------------------------------------------------
autovacuum = on
autovacuum_max_workers = 4
autovacuum_naptime = 30s
autovacuum_vacuum_threshold = 50
autovacuum_vacuum_scale_factor = 0.05   # Vacuum when 5% of table changed
autovacuum_analyze_threshold = 50
autovacuum_analyze_scale_factor = 0.02  # Analyze when 2% of table changed
autovacuum_vacuum_cost_delay = 2ms
autovacuum_vacuum_cost_limit = 1000
autovacuum_freeze_max_age = 200000000

# Table-specific autovacuum for high-traffic tables (via ALTER TABLE)
# ALTER TABLE tickets SET (autovacuum_vacuum_scale_factor = 0.01);
# ALTER TABLE payments SET (autovacuum_vacuum_scale_factor = 0.01);
# ALTER TABLE cashless_transactions SET (autovacuum_vacuum_scale_factor = 0.01);

# -----------------------------------------------------------------------------
# Logging
# -----------------------------------------------------------------------------
log_destination = 'stderr'
logging_collector = on
log_directory = 'log'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
log_rotation_age = 1d
log_rotation_size = 100MB
log_min_duration_statement = 500        # Log queries > 500ms
log_checkpoints = on
log_connections = on
log_disconnections = on
log_lock_waits = on
log_statement = 'ddl'                   # Log DDL statements
log_temp_files = 0                      # Log all temp files
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '
log_timezone = 'UTC'

# -----------------------------------------------------------------------------
# Query Performance Monitoring
# -----------------------------------------------------------------------------
shared_preload_libraries = 'pg_stat_statements,auto_explain'

# pg_stat_statements settings
pg_stat_statements.max = 10000
pg_stat_statements.track = all
pg_stat_statements.track_utility = on
pg_stat_statements.save = on

# auto_explain settings
auto_explain.log_min_duration = 1000    # Explain queries > 1s
auto_explain.log_analyze = on
auto_explain.log_buffers = on
auto_explain.log_timing = on
auto_explain.log_verbose = on

# -----------------------------------------------------------------------------
# Statement Behavior
# -----------------------------------------------------------------------------
statement_timeout = 60000               # 60 seconds max query time
lock_timeout = 30000                    # 30 seconds max lock wait
idle_in_transaction_session_timeout = 300000  # 5 minutes
deadlock_timeout = 1s

# -----------------------------------------------------------------------------
# Security
# -----------------------------------------------------------------------------
ssl = on
ssl_cert_file = '/etc/postgresql/ssl/server.crt'
ssl_key_file = '/etc/postgresql/ssl/server.key'
ssl_ca_file = '/etc/postgresql/ssl/ca.crt'
ssl_prefer_server_ciphers = on
ssl_ciphers = 'HIGH:MEDIUM:+3DES:!aNULL'
ssl_min_protocol_version = 'TLSv1.2'
password_encryption = scram-sha-256

# Row-level security
row_security = on

# -----------------------------------------------------------------------------
# Client Connection Defaults
# -----------------------------------------------------------------------------
timezone = 'UTC'
lc_messages = 'en_US.UTF-8'
lc_monetary = 'en_US.UTF-8'
lc_numeric = 'en_US.UTF-8'
lc_time = 'en_US.UTF-8'
default_text_search_config = 'pg_catalog.english'

# -----------------------------------------------------------------------------
# Resource Usage
# -----------------------------------------------------------------------------
max_worker_processes = 8
max_parallel_workers_per_gather = 4
max_parallel_workers = 8
max_parallel_maintenance_workers = 4
parallel_leader_participation = on

# -----------------------------------------------------------------------------
# Cost-Based Vacuum Delay
# -----------------------------------------------------------------------------
vacuum_cost_delay = 0
vacuum_cost_page_hit = 1
vacuum_cost_page_miss = 10
vacuum_cost_page_dirty = 20
vacuum_cost_limit = 200

# -----------------------------------------------------------------------------
# Platform Specific (Linux)
# -----------------------------------------------------------------------------
# These require kernel configuration:
# echo "vm.nr_hugepages = 4096" >> /etc/sysctl.conf
# sysctl -p
